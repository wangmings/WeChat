# coding: utf-8# 线程import time, bugimport ctypesimport threadingfrom concurrent.futures import ThreadPoolExecutor import multiprocessingfrom multiprocessing import active_children# 创建进程类class Process:    # 存储启动进程对象    __process_obj = []    # 初始化对象    def __init__(self):        self._process_all = []        self.__process_obj.append(self)        # 获取进程名字: 私有    def __getProcessName(self, function, process):        process.start()        self._process_all.append({            'name':process.name,            'childPId':process.pid,            'parentPId':process._parent_pid,            'function':function.__name__,             'process':process             })    # 进程重名处理    def __handleSameName(self):        process = self._process_all         d1, d2 = [f['function'] for f in process], []                for f in list(set(d1)):            num = d1.count(f)            if num > 1: d2.append({'function':f, 'num':num})                        for d in d2:            num = 0            for p in process:                if d['function'] == p['function']:                    num += 1; p['function'] += '~%d' %(num)         return process                  # 创建进程    def createProcess(self, function, arg='null'):        process = multiprocessing.Process(target=function) if arg == 'null' else multiprocessing.Process(target=function, args=(arg,))        self.__getProcessName(function,process)    # 查看存活进程    def alive(self, alls=False, *function):        if alls == False:            self.manageProcess(1, *function)        else:                self.manageAllProcess(1, *function)    # 等待结束进程    def join(self, alls=False, *function):        if alls == False:            self.manageProcess(2, *function)        else:                self.manageAllProcess(2, *function)    # 关闭结束进程    def close(self, alls=False, *function):        if alls == False:            self.manageProcess(3, *function)        else:                self.manageAllProcess(3, *function)    # 管理所有启动线程    def manageAllProcess(self, model = 1, *function):        d1, d2 = [], []        process = self._process_all        processObj = self.__process_obj                if len(process) > 0  and len(processObj) > 1:            d1.extend(process)            for obj in self.__process_obj: d2.extend(obj._process_all)            self._process_all = d2            self.manageProcess(model, *function)            self._process_all = d1        else:             self.manageProcess(model, *function)    # 进程管理    def manageProcess(self, model = 1, *function):        nameAll, model = [], ['alive','join','close'][model - 1]        processAll = self.__handleSameName()        if len(function) > 0:             for name in function:                if type(name) != str: name = name.__name__                nameAll.append(name)                    if model == 'alive':            for process in processAll:                if process['process'].is_alive():                    print('ActiveProcess: %s Function: %s' %(process['name'],process['function']))                elif model == 'join':            for process in processAll: process['process'].join()            num = len(active_children())            if num == 0: print('All ChildProcess End !')            return True if num == 0 else False               elif model == 'close':            for name in nameAll:                for process in processAll:                    if name == process['function']:                        process['process'].terminate()                        process['process'].join()                        # 创建线程类class Thread:    # 定义私有变量: 不会初始化: 记录所有启动线程对象    __thread_obj = []       # 初始化对象: start: 1:开启线程锁 2:开启线程池 3:全开 pool:线程池大小    def __init__(self, pool=0):        self._thread_all = []        self._threadPool_all = []        self.__thread_obj.append(self)        self.__thread_lock = threading.Lock()        self.__thread_pool = ThreadPoolExecutor() if pool == 0 else ThreadPoolExecutor(pool)        # print(id(self))           # 获取启动线程名字: 私有    def __getStartThread(self, function, thread):         thread.start()        self._thread_all.append({            'name':thread.name,             'id':thread.ident,            'thread':thread,             'function':function.__name__        })    # 定义内部锁的线程    def __threadLock(self, function, arg='null'):        with self.__thread_lock:            function() if arg == 'null' else function(arg)    # 通过抛出异常来结束运行的线程    def __async_raise(self, tid):        tid = ctypes.c_long(tid)         res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(SystemExit))        if res > 1:             ctypes.pythonapi.PyThreadState_SetAsyncExc(thid, 0)             print('Exception raise failure')    # 定义线程处理: 处理启动线程重名问题    def __handleSameName(self):        d1, d2, d3 = [], [], []         thread = self._thread_all         for f in thread: d1.append(f['function'])                 for f in list(set(d1)):            num = d1.count(f)            if num > 1: d2.append({'function':f, 'num':num})                        for d in d2:            num = 0            for t in thread:                if d['function'] == t['function']:                    num += 1; t['function'] += '~%d' %(num)         for t in threading.enumerate():            for t2 in thread:                if t.name == t2['name'] and t.ident == t2['id']:                     t2['thread'] = t                      d3.append(t2)                return d3             # 定义管理所有的线程列表    def __manageAllThread(self, model = 1, *function):        d1, d2 = [], []        thread = self._thread_all        threadObj = self.__thread_obj                if len(thread) > 0  and len(threadObj) > 1:            d1.extend(thread)            for obj in self.__thread_obj: d2.extend(obj._thread_all)            self._thread_all = d2            self.__manageThread(model, *function)            self._thread_all = d1        else:             self.__manageThread(model, *function)        # 定义管理线程列表    def __manageThread(self, model = 1, *function):        num, nameAll, storage = 0, [], []        model =  ['alive','join','close'][model - 1]                threadAll = self.__handleSameName()         if len(function) > 0:            for name in function:                if type(name) != str: name = name.__name__                nameAll.append(name)                                           if model == 'alive':            for thread in threadAll:                print('ActiveThread: %s: Function: %s'  %(thread['name'], thread['function']))                        elif model == 'join':            if len(nameAll) > 0:                for name in nameAll:                    for thread in threadAll:                        if name == thread['function']:                             thread['thread'].join()                            num += 1                            break                if num == len(nameAll):                     print('JoinThread: The current child thread end.',nameAll)                else:                    print('JoinThread: There is no such thread under the current object.',nameAll)                                            else:                for thread in threadAll:                    thread['thread'].join()                print('JoinThread: The all current child threads end.')                            elif model == 'close':            num = len(nameAll)            storage = nameAll.copy()            if num > 0:                for i in range(0, num):                    for thread in threadAll:                        if thread['function'] == nameAll[i]:                            self.__async_raise(thread['id'])                            thread['thread'].join()                            del storage[i]                             break                                        if num != len(storage): print('CloseThread: No thread found. ',storage)                      else: print('No threads to close')    # 创建定时线程    def __createTimerThread(self, timer = 0, function = 'null',  arg='null'):         if timer == 0 or function == 'null':            print('create timer thread no set function timer args')        else:            thread = threading.Timer(timer,function) if arg == 'null' else threading.Timer(timer,function,args=(arg,))            self.__getStartThread(function,thread)     # 创建线程    def __createThread(self, function, arg='null'):         thread = threading.Thread(target=function) if arg == 'null' else threading.Thread(target=function, args=(arg,))        self.__getStartThread(function,thread)                    # 创建带锁的线程:    def __createLockThread(self, function, arg='null'):        thread = threading.Thread(target=self.__threadLock, args=(function,)) if arg == 'null' else threading.Thread(target=self.__threadLock, args=(function,arg))        self.__getStartThread(function,thread)     # 创建线程池    def __createThreadPool(self, function, arg='null'):        pool = self.__thread_pool        thread = pool.submit(function) if arg == 'null' else pool.submit(function,arg)        self._threadPool_all.append(thread)    # 创建带锁线程池:尽量不要使用该方法    def __createThreadPoolLock(self, function, arg='null'):        pool = self.__thread_pool        thread = pool.submit(self.__threadLock,function) if arg == 'null' else pool.submit(self.__threadLock,function,arg)        self._threadPool_all.append(thread)            # 查看存活线程池    def __aliveThreadPool(self):        for t in threading.enumerate():            if t.name != 'MainThread':                print('ThreadPool: %s id: %s'  %(t.name,t.ident))            # 等待线程池执行结束返回结果    def __getThreadPoolData(self):        poolData = []         self.joinThreadPool()        for thread in self._threadPool_all:            res = thread.result()            if res != None: poolData.append(thread.result())           return poolData    #-------------------------------------------------------#    # 查看当前或者所有存活线程    def alive(self, alls=False, *function):        self.__manageThread(1, *function) if alls == False else self.__manageAllThread(1, *function)                  # 等待当前或者所有结束线程    def join(self, alls=False, *function):        self.__manageThread(2, *function) if alls == False else self.__manageAllThread(2, *function)                  # 关闭当前或者所有结束线程    def close(self, alls=False, *function):        self.__manageThread(3, *function) if alls == False else self.__manageAllThread(3, *function)          # 创建线程    def start(self, function, arg='null'):        self.__createThread(function,arg)    # 定时线程    def timer(self, timer = 0, function = 'null',  arg='null'):        self.__createTimerThread(timer,function,arg)    # 创建带锁线程    def lock(self, function, arg='null'):        self.__createLockThread(function,arg)    # 创建线程池    def pool(self, function, arg='null'):        self.__createThreadPool(function,arg)    # 创建锁的线程池    def lockPool(self, function, arg='null'):        self.__createThreadPoolLock(function,arg)    # 查看存活线程池    def alivePool(self):        self.__aliveThreadPool()    # 等待线程池结束    def joinPool(self):        self.__thread_pool.shutdown()    # 等待线程池执行结束返回结果    def dataPool(self):        return self.__getThreadPoolData() # 普通线程: 创建多个线程# def funs(num): #     time.sleep(2)#     print("funs: "+ str(num))# def funs2(num): #     time.sleep(2)#     print("funs2: "+ str(num))# def funs3(num): #     time.sleep(2)#     print("funs3: "+ str(num))# def mac(num): #     time.sleep(2)#     print("mac: "+ str(num)) # # 初始化线程对象 # threads = Thread()# threads2 = Thread()# for i in range(5):#     # 创建单线程, 函数:fun 参数:1#     threads.__createThread(funs,i)#     threads.__createThread(funs2,i)# threads.__createThread(funs3,i)# # # 查看当前存活的线程# threads.__manageThread()# print('**--------------------')# for i in range(5):#     # 创建单线程, 函数:fun 参数:1#     threads2.__createThread(mac,i)# # 查看当前存活的线程# threads2.__manageAllThread()# print('-------------------**')# threads2.__manageThread()# 查看所有线程是否结束# threads2.__manageThread(2,funs3)# threads2.__manageAllThread(2,funs3)# 创建定时执行线程# def funs(a):#     for i in range(20):#         time.sleep(1)#         print("funs: "+ str(i))# # 创建定时执行线程# threads = Thread()# print('定时线程')# # 创建定时线程, 时间:3秒后执行 函数:fun 参数:6# threads.__createTimerThread(3,funs,6)# # 查看存活线程# threads.__manageThread()   # # 普通线程: 关闭死循环线程# def funs(a):#     num = 0#     while True:#         num = num + 1#         print("funs: "+ str(num))#         time.sleep(1)# def funs2(a):#     for i in range(20):#         time.sleep(1)#         print("funs2: "+ str(i))# # 初始化线程对象 # threads = Thread()# # 创建单线程, 函数:fun 参数:1# threads.__createThread(funs,1)# # 创建单线程, 函数:fun2 参数:2# threads.__createThread(funs2,2)# # 查看当前存活的线程# # threads.__manageThread()# threads.alive()# # 延迟五秒 # time.sleep(5)# print('线程结束:----------------funs')# # 五秒后结束线程: 函数:fun# # threads.__manageThread(3,funs)# threads.close(funs)# # 查看当前存活的线程# # threads.__manageThread()# threads.alive()# # 查看所有线程是否结束# threads.join() # # threads.__manageThread(2)# # 普通线程: 创建多个线程# def funs(num): #     for i in range(10):   #         print("fun: "+ str(num + i))#         time.sleep(1)# # 初始化线程对象 # threads = Thread()# for i in range(20):#     # 创建单线程, 函数:fun 参数:1#     threads.__createThread(funs,i)# # 查看当前存活的线程# threads.alive()# # 查看所有线程是否结束# threads.join()# 创建一个带锁的线程: 多线程操作一个全局变量# nums = 100# def funs(a):    #     global nums#     tmp = nums#     time.sleep(0.1)#     nums = tmp - 1#     print(nums)# # 初始化线程对象 # threads = Thread()# for i in range(100):#     # 创建单线程, 函数:fun 参数:1#     threads.lock(funs,i) # # 查看当前存活的线程# threads.alive()# # 查看所有线程是否结束# threads.join()# # 线程池使用: 注意: 线程池不能使用线程重开的一些方法# def funs(n):#     print(n)#     time.sleep(2)#     return n*n# # 初始化5个线程池: 一次执行5个线程# threads = Thread(5)# for i in range(20):#     # 创建20个线程并放入线程池中#     threads.__createThreadPool(funs,i)# threads.__aliveThreadPool()# # 线程池中线程结束后：获取返回数据# t = threads.__getThreadPoolData()# print(t)# 创建一个带锁的线程: 多线程操作一个全局变量# nums = 100# def funs(a):    #     global nums#     tmp = nums#     time.sleep(0.1)#     nums = tmp - 1#     print(nums)# # 初始化线程对象 # threads = Thread(5)# for i in range(100):#     # 创建20个线程并放入线程池中#     threads.__createThreadPoolLock(funs,i)# threads.__aliveThreadPool()# # 线程池中线程结束后：获取返回数据# t = threads.__getThreadPoolData()# print(t) # def funs(num):#     print('funs: %d' %(num))# if __name__ == '__main__':#     process = Process()#     for i in range(10):#         process.createProcess(funs,i)#     process.printAliveProcess(1)#     time.sleep(6)#     print('------------------')#     process.joinProcess()# def funs(name):#     for i in range(10):#         time.sleep(2)#         print('%s %d' %(name,i))# def funs2(name):#     while True:#         time.sleep(2)#         print(name)# if __name__ == '__main__':#     process = Process()#     process.createProcess(funs,'funs')#     process.createProcess(funs2,'funs2')#     process.startProcess()#     process.printAliveProcess()#     time.sleep(6)#     print('------------------')#     process.closeProcess(funs2)#     process.printAliveProcess()#     process.joinProcess()# def funs(name):#     print(name)# def funs2(name):#     print(name)# if __name__ == '__main__':#     process = Process()#     process.createProcess(funs,'funs')#     process.createProcess(funs2,'funs2')#     process.startProcess()#     process.joinProcess()# def funs(num):#     print('funs: %d' %(num))# def funs2(num):#     print('funs2: %d' %(num))# def funs3(num):#     print('funs3: %d' %(num))# if __name__ == '__main__':#     process = Process()#     process2 = Process()#     for i in range(5):#         process.createProcess(funs,i)#         process.createProcess(funs2,i)#     process.alive()#     print('**------------------')#     process2.createProcess(funs3,66)#     # process2.alive()#     process2.alive()    #     time.sleep(2)#     print('------------------')#     process.join()